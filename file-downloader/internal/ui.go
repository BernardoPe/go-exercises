package internal

// Partially generated by Claude Sonnet 4.5 :)

import (
	"fmt"
	"strings"
	"sync"
	"time"
)

const (
	// ProgressUpdateInterval is how often to update the progress display
	ProgressUpdateInterval = 1 * time.Second

	// SpeedUpdateThreshold is the minimum time between speed calculations
	SpeedUpdateThreshold = 0.5

	// ProgressBarWidth is the width of the progress bar in characters
	ProgressBarWidth = 50
)

// ProgressInfo tracks download progress and speed
type ProgressInfo struct {
	mu             sync.RWMutex
	downloaded     int64
	startTime      time.Time
	completionTime time.Time
	lastUpdate     time.Time
	lastBytes      int64
	currentSpeed   float64
	complete       bool
}

// StartProgressListener monitors downloads and displays progress bars with speed and ETA
func StartProgressListener(downloads []*FileDownload, wg *sync.WaitGroup) {
	progressInfos := make([]*ProgressInfo, len(downloads))
	for i := range downloads {
		progressInfos[i] = &ProgressInfo{
			downloaded: 0,
			startTime:  time.Now(),
			lastUpdate: time.Now(),
			lastBytes:  0,
			complete:   false,
		}
	}

	for range downloads {
		fmt.Println()
	}

	for i, download := range downloads {
		wg.Add(1)
		go listenToProgress(download, progressInfos[i], wg)
	}

	wg.Add(1)
	go updateDisplay(downloads, progressInfos, wg)
}

func listenToProgress(download *FileDownload, info *ProgressInfo, wg *sync.WaitGroup) {
	defer wg.Done()
	for bytes := range download.LoadedBytes {
		info.mu.Lock()
		info.downloaded += bytes
		updateSpeed(info)
		info.mu.Unlock()
	}
	info.mu.Lock()
	info.completionTime = time.Now()
	info.complete = true
	info.mu.Unlock()
}

func updateDisplay(downloads []*FileDownload, progressInfos []*ProgressInfo, wg *sync.WaitGroup) {
	defer wg.Done()
	ticker := time.NewTicker(ProgressUpdateInterval)
	defer ticker.Stop()

	allComplete := false
	for !allComplete {
		<-ticker.C

		if len(downloads) > 0 {
			fmt.Printf("\033[%dA", len(downloads))
		}

		allComplete = true
		for i, download := range downloads {
			info := progressInfos[i]
			printProgress(download, info, i)

			info.mu.RLock()
			if !info.complete {
				allComplete = false
			}
			info.mu.RUnlock()
		}
	}

	fmt.Printf("\033[%dA", len(downloads))
	for i, download := range downloads {
		info := progressInfos[i]
		printProgress(download, info, i)
	}
}

// updateSpeed updates the current download speed. Must be called with info.mu locked.
func updateSpeed(info *ProgressInfo) {
	now := time.Now()
	timeDiff := now.Sub(info.lastUpdate).Seconds()

	if timeDiff >= SpeedUpdateThreshold {
		bytesDiff := info.downloaded - info.lastBytes
		info.currentSpeed = float64(bytesDiff) / timeDiff
		info.lastUpdate = now
		info.lastBytes = info.downloaded
	}
}

func printProgress(download *FileDownload, info *ProgressInfo, index int) {
	info.mu.RLock()
	defer info.mu.RUnlock()

	totalBytes := download.TotalBytes()

	var percentage float64
	if totalBytes > 0 {
		percentage = float64(info.downloaded) / float64(totalBytes) * 100
	} else {
		percentage = 0
	}

	filledWidth := int(float64(ProgressBarWidth)*percentage/100 + 0.5)
	bar := strings.Repeat("█", filledWidth) + strings.Repeat("░", ProgressBarWidth-filledWidth)

	downloadedMB := float64(info.downloaded) / (1024 * 1024)
	totalMB := float64(totalBytes) / (1024 * 1024)

	if info.complete {
		elapsed := info.completionTime.Sub(info.startTime)
		avgSpeed := float64(info.downloaded) / elapsed.Seconds()
		fmt.Printf("\r\033[K[%d] %s %.1f%% | %.2f/%.2f MB | Avg: %s | Time: %s\n",
			index+1, bar, percentage, downloadedMB, totalMB,
			formatSpeed(avgSpeed), formatDuration(elapsed))
	} else {
		eta := ""
		if info.currentSpeed > 0 {
			remainingBytes := totalBytes - info.downloaded
			etaSeconds := float64(remainingBytes) / info.currentSpeed
			eta = formatDuration(time.Duration(etaSeconds * float64(time.Second)))
		} else {
			eta = "calculating..."
		}
		fmt.Printf("\r\033[K[%d] %s %.1f%% | %.2f/%.2f MB | Speed: %s | ETA: %s\n",
			index+1, bar, percentage, downloadedMB, totalMB,
			formatSpeed(info.currentSpeed), eta)
	}
}

func formatSpeed(bps float64) string {
	if bps < 1024 {
		return fmt.Sprintf("%.0f B/s", bps)
	} else if bps < 1024*1024 {
		return fmt.Sprintf("%.2f KB/s", bps/1024)
	}
	return fmt.Sprintf("%.2f MB/s", bps/(1024*1024))
}

func formatDuration(d time.Duration) string {
	d = d.Round(time.Second)
	h := d / time.Hour
	d -= h * time.Hour
	m := d / time.Minute
	d -= m * time.Minute
	s := d / time.Second

	if h > 0 {
		return fmt.Sprintf("%dh%dm%ds", h, m, s)
	} else if m > 0 {
		return fmt.Sprintf("%dm%ds", m, s)
	}

	return fmt.Sprintf("%ds", s)
}
